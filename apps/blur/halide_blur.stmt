module name=halide_blur, target=x86-64-linux-avx-avx2-f16c-fma-sse41
internal func halide_blur_par_for_blur_y_s0_y_y (__user_context, blur_y.s0.y.y, closure_arg) {
let closure_prototype = (void *)make_struct(reinterpret<(void *)>((uint64)0), reinterpret<(void *)>((uint64)0), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint1)0)
let blur_y = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 0)
let input = (void *)load_typed_struct_member((void *)closure_arg, closure_prototype, 1)
let blur_y.extent.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 2)
let blur_y.extent.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 3)
let blur_y.min.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 4)
let blur_y.min.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 5)
let blur_y.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 6)
let input.min.0 = load_typed_struct_member((void *)closure_arg, closure_prototype, 7)
let input.stride.1 = load_typed_struct_member((void *)closure_arg, closure_prototype, 8)
let t209 = load_typed_struct_member((void *)closure_arg, closure_prototype, 9)
let t210 = load_typed_struct_member((void *)closure_arg, closure_prototype, 10)
let t214 = load_typed_struct_member((void *)closure_arg, closure_prototype, 11)
let t217 = load_typed_struct_member((void *)closure_arg, closure_prototype, 12)
let t219 = load_typed_struct_member((void *)closure_arg, closure_prototype, 13)
let t220 = load_typed_struct_member((void *)closure_arg, closure_prototype, 14)
let t221 = load_typed_struct_member((void *)closure_arg, closure_prototype, 15)
let t213 = (uint1)load_typed_struct_member((void *)closure_arg, closure_prototype, 16)
let blur_y.s0.y.yi.base.s = min(blur_y.s0.y.y*32, blur_y.extent.1 + -32)
allocate blur_x[uint16 * blur_y.extent.0 * 4]
let t222 = blur_y.min.1 + blur_y.s0.y.yi.base.s
for (blur_y.s0.y.yi.$n.rebased, 0, 2) {
 let t225 = blur_y.s0.y.yi.$n.rebased + t222
 let t224 = (t225 % 4)*blur_y.extent.0
 let t223 = ((t225 + -2)*input.stride.1) + t210
 for (blur_y.s0.x.x, 0, t209) {
  if (0 < select(0 < blur_y.s0.x.x, max(min(blur_y.extent.0 - (blur_y.s0.x.x*16), 16), 0), 16)) {
   let blur_y.s0.x.v0.base.s = min(blur_y.s0.x.x*16, blur_y.extent.0 + -16)
   let blur_x.s0.x.min_2.s = select(0 < blur_y.s0.x.x, min(blur_y.s0.x.x*16, blur_y.extent.0), blur_y.s0.x.v0.base.s)
   produce blur_x {
    let blur_x.s0.x.v1.base.s = min(blur_x.s0.x.min_2.s, blur_y.s0.x.v0.base.s)
    let t185 = blur_x.s0.x.v1.base.s + t223
    blur_x[ramp(blur_x.s0.x.v1.base.s + t224, 1, 16)] = (input[ramp(t185 + 1, 1, 16)] + (input[ramp(t185 + 2, 1, 16)] + input[ramp(t185, 1, 16)]))/x16((uint16)3)
   }
  }
 }
}
let t228 = min(t214, t221)
let t230 = t214 - t219
let t227 = 0 - t219
let t226 = blur_y.min.1 + blur_y.s0.y.yi.base.s
for (blur_y.s0.y.yi.$n, 0, 32) {
 produce blur_x {
  let t187 = ((blur_y.s0.y.yi.$n + t226)*input.stride.1) + t210
  blur_x[ramp((((blur_y.s0.y.yi.$n + t226) + 2) % 4)*blur_y.extent.0, 1, 16)] = (input[ramp(t187 + 1, 1, 16)] + (input[ramp(t187 + 2, 1, 16)] + input[ramp(t187, 1, 16)]))/x16((uint16)3)
 }
 consume blur_x {
  let t205 = blur_y.s0.y.yi.$n + t226
  blur_y[ramp((blur_y.s0.y.yi.$n + blur_y.s0.y.yi.base.s)*blur_y.stride.1, 1, 16)] = (blur_x[ramp(((t205 + 1) % 4)*blur_y.extent.0, 1, 16)] + (blur_x[ramp(((t205 + 2) % 4)*blur_y.extent.0, 1, 16)] + blur_x[ramp((t205 % 4)*blur_y.extent.0, 1, 16)]))/x16((uint16)3)
 }
 let t234 = blur_y.s0.y.yi.$n + t226
 let t232 = ((t234 + 2) % 4)*blur_y.extent.0
 let t231 = (input.stride.1*t234) + t210
 for (blur_y.s0.x.x.rebased, 0, t220 + -1) {
  if ((blur_y.s0.x.x.rebased*16) < (blur_y.extent.0 + -16)) {
   produce blur_x {
    let t190.s = (blur_y.s0.x.x.rebased*16) + t231
    blur_x[ramp(((blur_y.s0.x.x.rebased*16) + t232) + 16, 1, 16)] = (input[ramp(t190.s + 17, 1, 16)] + (input[ramp(t190.s + 18, 1, 16)] + input[ramp(t190.s + 16, 1, 16)]))/x16((uint16)3)
   }
  }
  consume blur_x {
   blur_y[ramp(((blur_y.s0.x.x.rebased*16) + ((blur_y.stride.1*t234) + t227)) + 16, 1, 16)] = (blur_x[ramp(((((t234 + 1) % 4)*blur_y.extent.0) + (blur_y.s0.x.x.rebased*16)) + 16, 1, 16)] + (blur_x[ramp(((((t234 + 2) % 4)*blur_y.extent.0) + (blur_y.s0.x.x.rebased*16)) + 16, 1, 16)] + blur_x[ramp((((t234 % 4)*blur_y.extent.0) + (blur_y.s0.x.x.rebased*16)) + 16, 1, 16)]))/x16((uint16)3)
  }
 }
 if (t213) {
  produce blur_x {
   let t193 = ((blur_y.s0.y.yi.$n + t226)*input.stride.1) + (((((input.stride.1*2) + t228) + blur_y.min.0) - t217) - input.min.0)
   blur_x[ramp(((((blur_y.s0.y.yi.$n + t226) + 2) % 4)*blur_y.extent.0) + t228, 1, 16)] = (input[ramp(t193 + 1, 1, 16)] + (input[ramp(t193 + 2, 1, 16)] + input[ramp(t193, 1, 16)]))/x16((uint16)3)
  }
  consume blur_x {
   let t207 = blur_y.s0.y.yi.$n + t226
   blur_y[ramp((blur_y.stride.1*t207) + t230, 1, 16)] = (blur_x[ramp((((t207 + 1) % 4)*blur_y.extent.0) + t214, 1, 16)] + (blur_x[ramp((((t207 + 2) % 4)*blur_y.extent.0) + t214, 1, 16)] + blur_x[ramp(((t207 % 4)*blur_y.extent.0) + t214, 1, 16)]))/x16((uint16)3)
  }
 }
}
free blur_x
}


external_plus_metadata func halide_blur (input, blur_y) {
assert(reinterpret<uint64>((struct halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
assert(reinterpret<uint64>((struct halide_buffer_t *)blur_y.buffer) != (uint64)0, halide_error_buffer_argument_is_null("blur_y"))
let blur_y = (void *)_halide_buffer_get_host((struct halide_buffer_t *)blur_y.buffer)
let blur_y.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)blur_y.buffer)
let blur_y.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)blur_y.buffer)
let blur_y.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)blur_y.buffer)
let blur_y.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)blur_y.buffer, 0)
let blur_y.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)blur_y.buffer, 0)
let blur_y.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)blur_y.buffer, 0)
let blur_y.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)blur_y.buffer, 1)
let blur_y.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)blur_y.buffer, 1)
let blur_y.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)blur_y.buffer, 1)
let input = (void *)_halide_buffer_get_host((struct halide_buffer_t *)input.buffer)
let input.type = (uint32)_halide_buffer_get_type((struct halide_buffer_t *)input.buffer)
let input.device_dirty = (uint1)_halide_buffer_get_device_dirty((struct halide_buffer_t *)input.buffer)
let input.dimensions = _halide_buffer_get_dimensions((struct halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 0)
let input.extent.0 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((struct halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((struct halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((struct halide_buffer_t *)input.buffer, 1)
let input.extent.0.required.s = let t235 = (16 < blur_y.extent.0) in (let t236 = (max(select(t235, ((blur_y.extent.0 + 15)/16)*16, blur_y.extent.0), blur_y.extent.0) + (((max(select(t235, max(blur_y.extent.0, 0), 16), 16) + 15)/16)*16)) in (let t237 = min(blur_y.extent.0, 16) in (max(min(t236 + -16, blur_y.extent.0), min(blur_y.extent.0 + 16, t236) + -15) - min(select(t235, min(blur_y.extent.0, 0), t237 + -16), t237 + -16))))
let input.min.0.required.s = let t238 = min(blur_y.extent.0, 16) in min(select(16 < blur_y.extent.0, min(blur_y.extent.0, 0), t238 + -16), t238 + -16)
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)blur_y.buffer)) {
 let t239 = max(blur_y.extent.0, 16) in (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)blur_y.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)blur_y.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 1, 16, 2, (struct halide_dimension_t *)make_struct((min(blur_y.extent.0, 16) + blur_y.min.0) + -16, t239, 1, 0, (min(blur_y.extent.1, 32) + blur_y.min.1) + -32, max(blur_y.extent.1, 32), t239, 0), (uint64)0)
}
if ((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer)) {
 (struct halide_buffer_t *)_halide_buffer_init((struct halide_buffer_t *)input.buffer, (struct halide_dimension_t *)_halide_buffer_get_shape((struct halide_buffer_t *)input.buffer), reinterpret<(void *)>((uint64)0), (uint64)0, reinterpret<(struct halide_device_interface_t *)>((uint64)0), 1, 16, 2, (struct halide_dimension_t *)make_struct(blur_y.min.0 + input.min.0.required.s, input.extent.0.required.s + 1, 1, 0, (min(blur_y.extent.1, 32) + blur_y.min.1) + -32, max(blur_y.extent.1, 32) + 2, input.extent.0.required.s + 1, 0), (uint64)0)
}
if (!((uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)blur_y.buffer) || (uint1)_halide_buffer_is_bounds_query((struct halide_buffer_t *)input.buffer))) {
 assert(blur_y.type == (uint32)69633, halide_error_bad_type("Output buffer blur_y", blur_y.type, (uint32)69633))
 assert(blur_y.dimensions == 2, halide_error_bad_dimensions("Output buffer blur_y", blur_y.dimensions, 2))
 assert(input.type == (uint32)69633, halide_error_bad_type("Input buffer input", input.type, (uint32)69633))
 assert(input.dimensions == 2, halide_error_bad_dimensions("Input buffer input", input.dimensions, 2))
 assert(16 <= blur_y.extent.0, let t240 = (blur_y.extent.0 + blur_y.min.0) in halide_error_access_out_of_bounds("Output buffer blur_y", 0, (min(blur_y.extent.0, 16) + blur_y.min.0) + -16, t240 + -1, blur_y.min.0, t240 + -1))
 assert(32 <= blur_y.extent.1, let t241 = (blur_y.extent.1 + blur_y.min.1) in halide_error_access_out_of_bounds("Output buffer blur_y", 1, (min(blur_y.extent.1, 32) + blur_y.min.1) + -32, t241 + -1, blur_y.min.1, t241 + -1))
 assert(let t242 = (blur_y.min.0 + input.min.0.required.s) in ((input.min.0 <= t242) && (((t242 + input.extent.0.required.s) + 1) <= (input.extent.0 + input.min.0))), let t243 = (blur_y.min.0 + input.min.0.required.s) in halide_error_access_out_of_bounds("Input buffer input", 0, t243, t243 + input.extent.0.required.s, input.min.0, (input.extent.0 + input.min.0) + -1))
 assert(0 <= input.extent.0, halide_error_buffer_extents_negative("Input buffer input", 0, input.extent.0))
 assert((input.min.1 <= blur_y.min.1) && (((blur_y.extent.1 + blur_y.min.1) + 2) <= (input.extent.1 + input.min.1)), halide_error_access_out_of_bounds("Input buffer input", 1, blur_y.min.1, (blur_y.extent.1 + blur_y.min.1) + 1, input.min.1, (input.extent.1 + input.min.1) + -1))
 assert(0 <= input.extent.1, halide_error_buffer_extents_negative("Input buffer input", 1, input.extent.1))
 assert(blur_y.stride.0 == 1, halide_error_constraint_violated("blur_y.stride.0", blur_y.stride.0, "1", 1))
 assert(input.stride.0 == 1, halide_error_constraint_violated("input.stride.0", input.stride.0, "1", 1))
 let blur_y.total_extent.1 = int64(blur_y.extent.1)*int64(blur_y.extent.0)
 let input.total_extent.1 = int64(input.extent.1)*int64(input.extent.0)
 assert((uint64)abs(int64(blur_y.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("blur_y", (uint64)abs(int64(blur_y.extent.0)), (uint64)2147483647))
 assert((uint64)abs(int64(blur_y.extent.1)*int64(blur_y.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("blur_y", (uint64)abs(int64(blur_y.extent.1)*int64(blur_y.stride.1)), (uint64)2147483647))
 assert(blur_y.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("blur_y", blur_y.total_extent.1, (int64)2147483647))
 assert((uint64)abs(int64(input.extent.0)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.0)), (uint64)2147483647))
 assert((uint64)abs(int64(input.extent.1)*int64(input.stride.1)) <= (uint64)2147483647, halide_error_buffer_allocation_too_large("input", (uint64)abs(int64(input.extent.1)*int64(input.stride.1)), (uint64)2147483647))
 assert(input.total_extent.1 <= (int64)2147483647, halide_error_buffer_extents_too_large("input", input.total_extent.1, (int64)2147483647))
 assert(!blur_y.device_dirty, halide_error_device_dirty_with_no_device_support("Output buffer blur_y"))
 assert(!input.device_dirty, halide_error_device_dirty_with_no_device_support("Input buffer input"))
 assert(blur_y != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Output buffer blur_y"))
 assert(input != reinterpret<(void *)>((uint64)0), halide_error_host_is_null("Input buffer input"))
 produce blur_y {
  let t219 = blur_y.min.1*blur_y.stride.1
  let t220 = blur_y.extent.0/16
  let t221 = t220*16
  let t213 = (blur_y.extent.0 % 16) != 0
  let t214 = min(blur_y.extent.0 + -16, t221)
  let t208 = (blur_y.extent.1 + 31)/32
  let t209 = (blur_y.extent.0 + 15)/16
  let t217 = input.min.1*input.stride.1
  let t210 = (((2 - input.min.1)*input.stride.1) + blur_y.min.0) - input.min.0
  let parallel_closure = (void *)make_struct(blur_y, input, blur_y.extent.0, blur_y.extent.1, blur_y.min.0, blur_y.min.1, blur_y.stride.1, input.min.0, input.stride.1, t209, t210, t214, t217, t219, t220, t221, t213)
  let closure_result = halide_do_par_for((halide_task_t)::halide_blur_par_for_blur_y_s0_y_y, 0, t208, (uint8_t *)(parallel_closure))
  assert(closure_result == 0, closure_result)
 }
}
}


